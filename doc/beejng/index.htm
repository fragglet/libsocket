<!--
     Changes by Richard Dawe <richdawe@bigfoot.com> for incorporation into
     libsocket's documentation:

     . clientserver.gif -> cli-serv.gif & links changed.
     . dataencap.gif    -> datencap.gif & links changed.
-->

<html>
<head>
<title>Beej's Guide to Network Programming</title>
</head>

<body>

<center><h1>Beej's Guide to Network Programming</h1>
<h2>Using Internet Sockets</h2>
<i>Version 1.5.5 (13-Jan-1999)</i><br>
<small>[<a href="http://www.ecst.csuchico.edu/~beej/guide/net">http://www.ecst.csuchico.edu/~beej/guide/net</a>]</small></center>

<hr>

<p>
<h2>Intro</h2>
Hey!  Socket programming got you down?  Is this stuff just a little too
difficult to figure out from the <tt>man</tt> pages?  You want to do
cool Internet programming, but you don't have time to wade through a gob
of <tt>struct</tt>s trying to figure out if you have to call
<tt>bind()</tt> before you <tt>connect()</tt>, etc., etc.
</p>

<p>
Well, guess what!  I've already done this nasty business, and I'm dying
to share the information with everyone!  You've come to the right place.
This document should give the average competent C programmer the edge
s/he needs to get a grip on this networking noise.
</p>

<hr>

<p>
<h2>Audience</h2>
This document has been written as a tutorial, not a reference.  It is
probably at its best when read by individuals who are just starting out
with socket programming and are looking for a foothold.  It is certainly
not the <i>complete</i> guide to sockets programming, by any means.
</p>

<p>
Hopefully, though, it'll be just enough for those man pages to start
making sense... :-)
</p>

<hr>

<p>
<h2>Platform and Compiler</h2>
Most of the code contained within this document was compiled on a Linux
PC using Gnu's <tt>gcc</tt> compiler.  It was also found to compile on
HPUX using <tt>gcc</tt>.  Note that every code snippet was not
individually tested.
</p>

<hr>

<p>
<h2>Contents:</h2>
<ul>
<li><a href="#whatis">What is a socket?</a></li>
<li><a href="#twotypes">Two Types of Internet Sockets</a></li>
<li><a href="#lowlevel">Low level Nonsense and Network Theory</a></li>
<li><a href="#structs"><tt>struct</tt>s</a>--Know these, or aliens will destroy the planet!</li>
<li><a href="#convert">Convert the Natives!</a></li>
<li><a href="#ipaddr">IP Addresses and How to Deal With Them</a></li>
<li><a href="#socket"><tt>socket()</tt></a>--Get the File Descriptor!</li>
<li><a href="#bind"><tt>bind()</tt></a>--What port am I on?</li>
<li><a href="#connect"><tt>connect()</tt></a>--Hey, you!</li>
<li><a href="#listen"><tt>listen()</tt></a>--Will somebody please call me?</li>
<li><a href="#accept"><tt>accept()</tt></a>--"Thank you for calling port 3490."</li>
<li><a href="#sendrecv"><tt>send()</tt> and <tt>recv()</tt></a>--Talk to me, baby!</li>
<li><a href="#sendtorecv"><tt>sendto()</tt> and <tt>recvfrom()</tt></a>--Talk to me, DGRAM-style</li>
<li><a href="#closedown"><tt>close()</tt> and <tt>shutdown()</tt></a>--Get outta my face!</li>
<li><a href="#getpeername"><tt>getpeername()</tt></a>--Who are you?
<li><a href="#gethostname"><tt>gethostname()</tt></a>--Who am I?
<li><a href="#dns">DNS</a>--You say "whitehouse.gov", I say "198.137.240.100"</li>
<li><a href="#clientserver">Client-Server Background</a></li>
<li><a href="#simpleserver">A Simple Stream Server</a></li>
<li><a href="#simpleclient">A Simple Stream Client</a></li>
<li><a href="#datagram">Datagram Sockets</a></li>
<li><a href="#blocking">Blocking</a></li>
<li><a href="#select"><tt>select()</tt></a>--Synchronous I/O Multiplexing.  Cool!</li>
<li><a href="#reference">More references</a></li>
<li><a href="#disclaimer">Disclaimer and Call for Help</a></li>
</ul>
</p>

<hr>

<p>
<h2><a name="whatis">What is a socket?</a></h2>
You hear talk of "sockets" all the time, and perhaps you are wondering just
what they are exactly.  Well, they're this: a way to speak to
other programs using standard Unix file descriptors.
</p>

<p>
What?
</p>

<p> Ok--you may have heard some Unix hacker state, "Jeez,
<i>everything</i> in Unix is a file!"  What that person may have been
talking about is the fact that when Unix programs do any sort of I/O,
they do it by reading or writing to a file descriptor.  A file
descriptor is simply an integer associated with an open file.  But (and
here's the catch), that file can be a network connection, a FIFO, a
pipe, a terminal, a real on-the-disk file, or just about anything else.
Everything in Unix <b>is</b> a file!  So when you want to communicate
with another program over the Internet you're gonna do it through a file
descriptor, you'd better believe it.  </p>

<p> "Where do I get this file descriptor for network communication, Mr.
Smarty-Pants?" is probably the last question on your mind right now, but
I'm going to answer it anyway: You make a call to the <tt>socket()</tt>
system routine.  It returns the socket descriptor, and you communicate
through it using the specialized <tt>send()</tt> and <tt>recv()</tt>
("<tt><a href="man.cgi?send">man send</a></tt>", "<tt><a
href="man.cgi?recv">man recv</a></tt>") socket calls.  </p>

<p> "But, hey!" you might be exclaiming right about now.  "If it's a file
descriptor, why in the hell can't I just use the normal <tt>read()</tt>
and <tt>write()</tt> calls to communicate through the socket?"  The short
answer is, "You can!"  The longer answer is, "You can, but
<tt>send()</tt> and <tt>recv()</tt> offer much greater control over your
data transmission." </p>

<p> What next?  How about this: there are all kinds of sockets.  There
are DARPA Internet addresses (Internet Sockets), path names on a local
node (Unix Sockets), CCITT X.25 addresses (X.25 Sockets that you can
safely ignore), and probably many others depending on which Unix flavor
you run.  This document deals only with the first: Internet Sockets.
</p>

<hr>

<p>
<h2><a name="twotypes">Two Types of Internet Sockets</a></h2>
What's this?  There are two types of Internet sockets?  Yes.  Well, no.
I'm lying.  There are more, but I didn't want to scare you.  I'm only
going to talk about two types here.  Except for this sentence, where I'm
going to tell you that "Raw Sockets" are also very powerful and you
should look them up.
</p>

<p>
All right, already.  What are the two types?  One is "Stream Sockets";
the other is "Datagram Sockets", which may hereafter be referred to as
"<tt>SOCK_STREAM</tt>" and "<tt>SOCK_DGRAM</tt>", respectively.
Datagram sockets are sometimes called "connectionless sockets" (though
they can be <tt>connect()</tt>'d if you really want.  See <a
href="#connect"><tt>connect()</tt></a>, below.
</p>

<p>Stream sockets are reliable two-way connected communication streams.
If you output two items into the socket in the order "1, 2", they will
arrive in the order "1, 2" at the opposite end.  They will also be error
free.  Any errors you do encounter are figments of your own deranged
mind, and are not to be discussed here.
</p>

<p>
What uses stream sockets?  Well, you may have heard of the
<tt>telnet</tt> application, yes?  It uses stream sockets.  All the
characters you type need to arrive in the same order you type them,
right?  Also, WWW browsers use the HTTP protocol which uses stream
sockets to get pages.  Indeed, if you telnet to a WWW site on port 80,
and type "GET pagename", it'll dump the HTML back at you!
</p>

<p>
How do stream sockets achieve this high level of data transmission
quality?  They use a protocol called "The Transmission Control
Protocol", otherwise known as "TCP" (see <a
href="ftp://nic.ddn.mil/rfc/rfc793.txt">RFC-793</a> for extremely detailed
info on TCP.)  TCP makes sure your data arrives sequentially and
error-free.  You may have heard "TCP" before as the better half of
"TCP/IP" where "IP" stands for "Internet Protocol" (see <a
href="ftp://nic.ddn.mil/rfc/rfc791.txt">RFC-791</a>.)  IP deals with
Internet routing only.
</p>

<p>Cool.  What about Datagram sockets?  Why are they called
connectionless?  What is the deal, here, anyway?  Why are they
unreliable?  Well, here are some facts: if you send a datagram, it may
arrive.  It may arrive out of order.  If it arrives, the data within
the packet will be error-free.
</p>

<p>Datagram sockets also use IP for routing, but they don't use TCP;
they use the "User Datagram Protocol", or "UDP" (see <a
href="ftp://nic.ddn.mil/rfc/rfc768.txt">RFC-768</a>.)
</P>

<p>Why are they connectionless?  Well, basically, it's because you don't
have to maintain an open connection as you do with stream sockets.  You
just build a packet, slap an IP header on it with destination
information, and send it out.  No connection needed.  They are generally
used for packet-by-packet transfers of information.  Sample
applications: tftp, bootp, etc.
</p>

<p>
"Enough!" you may scream. "How do these programs even work if datagrams
might get lost?!"  Well, my human friend, each has it's own protocol on
top of UDP.  For example, the tftp protocol says that for each packet
that gets sent, the recipient has to send back a packet that says, "I
got it!" (an "ACK" packet.)  If the sender of the original packet gets
no reply in, say, five seconds, he'll re-transmit the packet until he
finally gets an ACK.  This acknowledgment procedure is very important
when implementing <tt>SOCK_DGRAM</tt> applications.
</p>

<hr>

<p>
<h2><a name="lowlevel">Low level Nonsense and Network Theory</a></h2>
Since I just mentioned layering of protocols, it's time to talk about
how networks really work, and to show some examples of how
<tt>SOCK_DGRAM</tt>
packets are built.  Practically, you can probably skip this section.
It's good background, however.
</p>

<p>
<a href="datencap.gif">
<img src="datencap.gif" border=0 alt="[Encapsulated Protocols Image]"
align=left>
</a>

<p>Hey, kids, it's time to learn about <b>Data Encapsulation</b>!
This is very very important.  It's so important that you might just
learn about it if you take the networks course here at Chico State ;-).
Basically, it says this: a packet is born, the packet is wrapped
("encapsulated") in a header (and maybe footer) by the first protocol
(say, the TFTP protocol), then the whole thing (TFTP header included) is
encapsulated again by the next protocol (say, UDP), then again by the
next (IP), then again by the final protocol on the hardware (physical)
layer (say, Ethernet).  
</p>

<p>
When another computer receives the packet, the hardware strips the
Ethernet header, the kernel strips the IP and UDP headers, the TFTP
program strips the TFTP header, and it finally has the data.
</p>

<p>
Now I can finally talk about the infamous <b>Layered Network Model</b>.
This Network Model describes a system of network functionality that has
many advantages over other models.  For instance, you can write sockets
programs that are exactly the same without caring how the data is
physically transmitted (serial, thin Ethernet, AUI, whatever) because
programs on lower levels deal with it for you.  The actual network
hardware and topology is transparent to the socket programmer.
</p>

<p>
Without any further ado, I'll present the layers of the full-blown
model.  Remember this for network class exams:

<ul>
<li>Application</li>
<li>Presentation</li>
<li>Session</li>
<li>Transport</li>
<li>Network</li>
<li>Data Link</li>
<li>Physical</li>
</ul>
</p>

<p>The Physical Layer is the hardware (serial, Ethernet, etc.).  The
Application  Layer is just about as far from the physical layer as you
can imagine--it's the place where users interact with the network.
</p>

<p>
Now, this model is so general you could probably use it as an automobile
repair guide if you really wanted to.  A layered model more consistent
with Unix might be:
<ul>
<li>Application Layer (<i>telnet, ftp, etc.</i>)</li>
<li>Host-to-Host Transport Layer (<i>TCP, UDP</i>)</li>
<li>Internet Layer (<i>IP and routing</i>)</li>
<li>Network Access Layer (<i>was Network, Data Link, and Physical</i>)</li>
</ul>
</p>

<p>
At this point in time, you can probably see how these layers correspond
to the encapsulation of the original data.
</p>

<p>
See how much work there is in building a simple packet?  Jeez!  And you
have to type in the packet headers yourself using "<tt>cat</tt>"!  Just
kidding.  All you have to do for stream sockets is <tt>send()</tt> the
data out.  All you have to do for datagram sockets is encapsulate the
packet in the method of your choosing and <tt>sendto()</tt> it out.  The
kernel builds the Transport Layer and Internet Layer on for you and the
hardware does the Network Access Layer.  Ah, modern technology.
</p>

<p>
So ends our brief foray into network theory.  Oh yes, I forgot to tell
you everything I wanted to say about routing: nothing!  That's right,
I'm not going to talk about it at all.  The router strips the packet to
the IP header, consults its routing table, blah blah blah.  Check out the <a
href="ftp://nic.ddn.mil/rfc/rfc791.txt">IP RFC</a> if you really really
care.  If you never learn about it, well, you'll live.
</p>

<hr>

<p>
<h2><a name="structs"><tt>struct</tt>s</a></h2>
Well, we're finally here.  It's time to talk about programming.  In this
section, I'll cover various data types used by the sockets interface,
since some of them are a real bitch to figure out.
</p>

<p>
First the easy one: a socket descriptor.  A socket descriptor is the
following type:
<pre>
    int
</pre>
Just a regular <tt>int</tt>.
</p>

<p>
Things get weird from here, so just read through and bear with me.  Know
this: there are two byte orderings: most significant byte (sometimes
called an "octet") first, or least significant byte first.  The former
is called "Network Byte Order".  Some machines store their numbers
internally in Network Byte Order, some don't.  When I say something has
to be in NBO, you have to call a function (such as <tt>htons()</tt>) to
change it from "Host Byte Order".  If I don't say "NBO", then you must
leave the value in Host Byte Order.
</p>

<p>My First Struct(TM)--<nobr><tt>struct sockaddr</tt></nobr>.  This
structure holds socket address information for many types of sockets:
<pre>
    struct sockaddr {
        unsigned short    sa_family;    /* address family, AF_xxx       */
        char              sa_data[14];  /* 14 bytes of protocol address */
    };
</pre>
<tt>sa_family</tt> can be a variety of things, but it'll be
"<tt>AF_INET</tt>" for everything we do in this document.
<tt>sa_data</tt> contains a destination address and port number for the
socket.  This is rather unwieldy.
</p>

<p>To deal with <nobr><tt>struct sockaddr</tt></nobr>, programmers
created a parallel structure: <nobr><tt>struct sockaddr_in</tt></nobr>
("in" for "Internet".)
<pre>
    struct sockaddr_in {
        short int          sin_family;  /* Address family               */
        unsigned short int sin_port;    /* Port number                  */
        struct in_addr     sin_addr;    /* Internet address             */
        unsigned char      sin_zero[8]; /* Same size as struct sockaddr */
    };
</pre>
This structure makes it easy to reference elements of the socket
address.  Note that <tt>sin_zero</tt> (which is included to pad the
structure to the length of a <nobr><tt>struct sockaddr</tt></nobr>)
should be set to all zeros with the function <tt>bzero()</tt> or
<tt>memset()</tt>.  Also, and this is the <b>important</b> bit, a
pointer to a <nobr><tt>struct sockaddr_in</tt></nobr> can be cast to a
pointer to a <nobr><tt>struct sockaddr</tt></nobr> and vice-versa.  So
even though <tt>socket()</tt> wants a <nobr><tt>struct sockaddr
*</tt></nobr>, you can still use a <nobr><tt>struct
sockaddr_in</tt></nobr> and cast it at the last minute!  Also, notice
that <tt>sin_family</tt> corresponds to <tt>sa_family</tt> in a
<nobr><tt>struct sockaddr</tt></nobr> and should be set to
"<tt>AF_INET</tt>".  Finally, the <tt>sin_port</tt> and
<tt>sin_addr</tt> must be in <b>Network Byte Order</b>!
</p>

<p>
"But," you object, "how can the entire structure, <nobr><tt>struct in_addr
sin_addr</tt></nobr>, be in Network Byte Order?"  This question requires
careful
examination of the structure <nobr><tt>struct in_addr</tt></nobr>, one of the worst
unions alive:
<pre>
    /* Internet address (a structure for historical reasons) */
    struct in_addr {
        unsigned long s_addr;
    };
</pre>
Well, it <i>used</i> to be a union, but now those days seem to be gone.  Good
riddance.  So if you have declared "<tt>ina</tt>" to be of type
<nobr><tt>struct sockaddr_in</tt></nobr>, then "<tt>ina.sin_addr.s_addr</tt>"
references the 4 byte IP address (in Network Byte Order).  Note that
even if your system still uses the God-awful union for <nobr><tt>struct
in_addr</tt></nobr>, you can still reference the 4 byte IP address in exactly
the same way as I did above (this due to <tt>#define</tt>s.)
</p>

<hr>

<p>
<h2><a name="convert">Convert the Natives!</a></h2>
We've now been lead right into the next section.  There's been too much
talk about this Network to Host Byte Order conversion--now is the time
for action!
</p>

<p>All righty.  There are two types that you can convert: <tt>short</tt>
(two bytes) and <tt>long</tt> (four bytes).  These functions work for the
<tt>unsigned</tt> variations as well.  Say you want to convert a
<tt>short</tt> from Host Byte Order to Network Byte Order.  Start with
"h" for "host", follow it with "to", then "n" for "network", and "s" for
"short": h-to-n-s, or <tt>htons()</tt> (read: "Host to Network Short").
</p>

<p>
It's almost too easy...
</p>

<p>You can use every combination if "n", "h", "s", and "l" you want, not
counting the really stupid ones.  For example, there is NOT a
<tt>stolh()</tt> ("Short to Long Host") function--not at this party,
anyway.  But there are:
<ul>
<li><tt>htons()</tt>--"Host to Network Short"</li>
<li><tt>htonl()</tt>--"Host to Network Long"</li>
<li><tt>ntohs()</tt>--"Network to Host Short"</li>
<li><tt>ntohl()</tt>--"Network to Host Long"</li>
</ul>
</p>

<p>
Now, you may think you're wising up to this.  You might think, "What do
I do if I have to change byte order on a <tt>char</tt>?"  Then you might
think, "Uh, never mind."  You might also think that since your 68000
machine already uses network byte order, you don't have to call
<tt>htonl()</tt> on your IP addresses.  You would be right, BUT if you
try to port to a machine that has reverse network byte order, your
program will fail.  Be portable!  This is a Unix world!  Remember: put
your bytes in Network Order before you put them on the network.
</p>

<p>
A final point: why do <tt>sin_addr</tt> and <tt>sin_port</tt> need to be
in Network Byte Order in a <nobr><tt>struct sockaddr_in</tt></nobr>, but
<tt>sin_family</tt> does not?  The answer: <tt>sin_addr</tt> and
<tt>sin_port</tt> get encapsulated in the packet at the IP and UDP
layers, respectively.  Thus, they must be in Network Byte Order.
However, the <tt>sin_family</tt> field is only used by the kernel to
determine what type of address the structure contains, so it must be in
Host Byte Order.  Also, since 
<tt>sin_family</tt> does <b>not</b> get sent out on the network, it can
be in Host Byte Order.
</p>

<hr>

<p>
<h2><a name="ipaddr">IP Addresses and How to Deal With Them</a></h2>
Fortunately for you, there are a bunch of functions  that allow you to
manipulate IP addresses.  No need to figure them out by hand and stuff
them in a <tt>long</tt> with the  <tt>&lt;&lt</tt> operator.
</p>

<p>First, let's say you have a <nobr><tt>struct sockaddr_in
ina</tt></nobr>, and you have an IP address "132.241.5.10" that you want
to store into it.  The function you want to use, <tt>inet_addr()</tt>,
converts an IP address in numbers-and-dots notation into an unsigned
long.  The assignment can be made as follows:
<pre>
    ina.sin_addr.s_addr = inet_addr("132.241.5.10");
</pre>
Notice that <tt>inet_addr()</tt> returns the address in Network Byte
Order already--you don't have to call <tt>htonl()</tt>.  Swell!
</p>

<p>
Now, the above code snippet isn't very robust because there is no error
checking.  See, <tt>inet_addr()</tt> returns <tt>-1</tt> on error.
Remember binary numbers?  <tt>(unsigned)-1</tt> just happens to
correspond to the IP address 255.255.255.255!  That's the broadcast
address!  Wrongo.  Remember to do your error checking properly.
</p>

<p>
All right, now you can convert string IP addresses to <tt>long</tt>s.
What about the other way around?  What if you have a <nobr><tt>struct
in_addr</tt></nobr> and you want to print it in numbers-and-dots
notation?  In this case, you'll want to use the function
<tt>inet_ntoa()</tt> ("ntoa" means "network to ascii") like this:
<pre>
    printf("%s",inet_ntoa(ina.sin_addr));
</pre>
That will print the IP address.  Note that <tt>inet_ntoa()</tt> takes a
<nobr><tt>struct in_addr</tt></nobr> as an argument, not a
<tt>long</tt>.  Also notice that it returns a pointer to a char.  This
points to a statically stored char array within <tt>inet_ntoa()</tt> so
that each time you call <tt>inet_ntoa()</tt> it will overwrite the last
IP address you asked for.  For example:
<pre>
    char *a1, *a2;
    .
    .
    a1 = inet_ntoa(ina1.sin_addr);  /* this is 198.92.129.1 */
    a2 = inet_ntoa(ina2.sin_addr);  /* this is 132.241.5.10 */
    printf("address 1: %s\n",a1);
    printf("address 2: %s\n",a2);
</pre>
will print:
<pre>
    address 1: 132.241.5.10
    address 2: 132.241.5.10
</pre>
If you need to save the address, <tt>strcpy()</tt> it to your own
character array.
</p>

<p>
That's all on this topic for now.  Later, you'll learn to convert a
string like "whitehouse.gov" into its corresponding IP address (see <a
href="#dns">DNS</a>, below.)
</p>

<hr>

<p>
<h2><a name="socket"><tt>socket()</tt>--Get the File Descriptor!</a></h2> 
I guess I can put it off no longer--I have to talk about the
<tt>socket()</tt> system call.  Here's the breakdown:
<pre>
    #include &lt;sys/types.h&gt; 
    #include &lt;sys/socket.h&gt; 

    int socket(int domain, int type, int protocol);
</pre>
But what are these arguments?  First, <tt>domain</tt> should be set to
"<tt>AF_INET</tt>", just like in the <nobr><tt>struct
sockaddr_in</tt></nobr> (above.)  Next, the <tt>type</tt> argument tells
the kernel what kind of socket this is: <tt>SOCK_STREAM</tt> or
<tt>SOCK_DGRAM</tt>.  Finally, just set <tt>protocol</tt> to
"<tt>0</tt>".  (Notes: there are many more <tt>domain</tt>s than I've
listed.  There are many more <tt>type</tt>s than I've listed.  See the
<a href="man.cgi?socket"><tt>socket()</tt> man page</a>.  Also, there's
a "better" way to get the <tt>protocol</tt>.  See the <a
href="man.cgi?getprotobyname"><tt>getprotobyname()</tt> man page</a>.)
</p>

<p><tt>socket()</tt> simply returns to you a socket descriptor that you can
use in later system calls, or <tt>-1</tt> on error.  The global variable
<tt>errno</tt> is set to the error's value (see the <a
href="man.cgi?perror"><tt>perror()</tt> man page</a>.)
</p>

<hr>

<p>
<h2><a name="bind"><tt>bind()</tt>--What port am I on?</a></h2>
Once you have a socket, you might have to associate that socket with a
port on your local machine.  (This is commonly done if you're going to
<tt>listen()</tt> for incoming connections on a specific port--MUDs do
this when they tell you to "telnet to x.y.z port 6969".)  If you're going to
only be doing a <tt>connect()</tt>, this may be unnecessary.  Read it
anyway, just for kicks.
</p>

<p>
Here is the synopsis for the <tt>bind()</tt> system call:
<pre>
    #include &lt;sys/types.h&gt; 
    #include &lt;sys/socket.h&gt; 

    int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
</pre>
<tt>sockfd</tt> is the socket file descriptor returned by
<tt>socket()</tt>.  <tt>my_addr</tt> is a pointer to a <nobr><tt>struct
sockaddr</tt></nobr> that contains information about your address,
namely, port and IP address.  <tt>addrlen</tt> can be set to
<nobr><tt>sizeof(struct sockaddr)</tt></nobr>.
</p>

<p>Whew.  That's a bit to absorb in one chunk.  Let's have an example:
<pre>
    #include &lt;string.h&gt; 
    #include &lt;sys/types.h&gt; 
    #include &lt;sys/socket.h&gt; 

    #define MYPORT 3490

    main()
    {
        int sockfd;
        struct sockaddr_in my_addr;

        sockfd = socket(AF_INET, SOCK_STREAM, 0); /* do some error checking! */

        my_addr.sin_family = AF_INET;     /* host byte order */
        my_addr.sin_port = htons(MYPORT); /* short, network byte order */
        my_addr.sin_addr.s_addr = inet_addr("132.241.5.10");
        bzero(&(my_addr.sin_zero), 8);    /* zero the rest of the struct */

        /* don't forget your error checking for bind(): */
        bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr));
        .
        .
        .
</pre>
There are a few things to notice here.  <tt>my_addr.sin_port</tt> is in
Network Byte Order.  So is <tt>my_addr.sin_addr.s_addr</tt>.  Another thing to
watch out for is that the header files might differ from system to
system.  To be sure, you should check your local man pages.
</p>

<p>
Lastly, on the topic of <tt>bind()</tt>, I should mention that some of
the process of getting your own IP address and/or port can can be automated:
<pre>
        my_addr.sin_port = 0; /* choose an unused port at random */
        my_addr.sin_addr.s_addr = INADDR_ANY;  /* use my IP address */
</pre>
See, by setting <tt>my_addr.sin_port</tt> to zero, you are telling
<tt>bind()</tt> to choose the port for you.  Likewise, by setting
<tt>my_addr.sin_addr.s_addr</tt> to <tt>INADDR_ANY</tt>, you are telling it to
automatically fill in the IP address of the machine the process is
running on.
</p>

<p>
If you are into noticing little things, you might have seen that I
didn't put <tt>INADDR_ANY</tt> into Network Byte Order!  Naughty me.
However, I have inside info: <tt>INADDR_ANY</tt> is really zero!  Zero
still has zero on bits even if you rearrange the bytes.  However,
purists will point out that there could be a parallel dimension where
<tt>INADDR_ANY</tt> is, say, 12 and that my code won't work there.
That's ok with me:
<pre>
        my_addr.sin_port = htons(0); /* choose an unused port at random */
        my_addr.sin_addr.s_addr = htonl(INADDR_ANY);  /* use my IP address */
</pre>
Now we're so portable you probably wouldn't believe it.  I just wanted
to point that out, since most of the code you come across won't bother
running <tt>INADDR_ANY</tt> through <tt>htonl()</tt>.
</p>

<p>
<tt>bind()</tt> also returns <tt>-1</tt> on error and sets
<tt>errno</tt> to the error's value.
</p>

<p>
Another thing to watch out for when calling <tt>bind()</tt>: don't go
underboard with your port numbers.  All ports below 1024 are RESERVED!
You can have any port number above that, right up to 65535 (provided
they aren't already being used by another program.)
</p>

<p>
One small extra final note about <tt>bind()</tt>: there are times when
you won't absolutely have to call it.  If you are <tt>connect()</tt>'ing
to a remote machine and you don't care what your local port is (as is
the case with <tt>telnet</tt>), you can simply call <tt>connect()</tt>,
it'll check to see if the socket is unbound, and will <tt>bind()</tt> it
to an unused local port.
</p>

<hr>

<p>
<h2><a name="connect"><tt>connect()</tt>--Hey, you!</a></h2>
Let's just pretend for a few minutes that you're a telnet application.
Your user commands you (just like in the movie <i>TRON</i>) to get a
socket file descriptor.  You comply and call <tt>socket()</tt>.  Next,
the user tells you to connect to "132.241.5.10" on port "23" (the
standard telnet port.)  Oh my God!  What do you do now?
</p>

<p>
Lucky for you, program, you're now perusing the section on
<tt>connect()</tt>--how to connect to a remote host.  You read furiously
onward, not wanting to disappoint your user...
</p>

<p>
The <tt>connect()</tt> call is as follows:
<pre>
    #include &lt;sys/types.h&gt; 
    #include &lt;sys/socket.h&gt; 

    int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);
</pre>
<tt>sockfd</tt> is our friendly neighborhood socket file descriptor, as
returned by the <tt>socket()</tt> call, <tt>serv_addr</tt> is a
<nobr><tt>struct sockaddr</tt></nobr> containing the destination port
and IP address, and <tt>addrlen</tt> can be set to
<nobr><tt>sizeof(struct sockaddr)</tt></nobr>.
</p>

<p>
Isn't this starting to make more sense?  Let's have an example:
<pre>
    #include &lt;string.h&gt; 
    #include &lt;sys/types.h&gt; 
    #include &lt;sys/socket.h&gt; 

    #define DEST_IP   "132.241.5.10"
    #define DEST_PORT 23

    main()
    {
        int sockfd;
        struct sockaddr_in dest_addr;   /* will hold the destination addr */

        sockfd = socket(AF_INET, SOCK_STREAM, 0); /* do some error checking! */

        dest_addr.sin_family = AF_INET;        /* host byte order */
        dest_addr.sin_port = htons(DEST_PORT); /* short, network byte order */
        dest_addr.sin_addr.s_addr = inet_addr(DEST_IP);
        bzero(&(dest_addr.sin_zero), 8);       /* zero the rest of the struct */

        /* don't forget to error check the connect()! */
        connect(sockfd, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr));
        .
        .
        .
</pre>
</p>

<p>Again, be sure to check the return value from
<tt>connect()</tt>--it'll return <tt>-1</tt> on error and set the
variable <tt>errno</tt>.
</p>

<p>
Also, notice that we didn't call <tt>bind()</tt>.  Basically, we don't
care about our local port number; we only care where we're going.  The
kernel will choose a local port for us, and the site we connect to will
automatically get this information from us.  No worries.
</p>

<hr>

<p>
<h2><a name="listen"><tt>listen()</tt>--Will somebody please call me?</a></h2>
Ok, time for a change of pace.  What if you don't want to connect to a
remote host.  Say, just for kicks, that you want to wait for incoming
connections and handle them in some way.  The process is two step: first
you <tt>listen()</tt>, then you <tt>accept()</tt> (see below.)
</p>

<p>
The listen call is fairly simple, but requires a bit of explanation:
<pre>
    int listen(int sockfd, int backlog);
</pre>
<tt>sockfd</tt> is the usual socket file descriptor from the
<tt>socket()</tt> system call.  <tt>backlog</tt> is the number of
connections allowed on the incoming queue.  What does that mean?  Well,
incoming connections are going to wait in this queue until you
<tt>accept()</tt> them (see below) and this is the limit on how many can
queue up.  Most systems silently limit this number to about 20; you can
probably get away with setting it to <tt>5</tt> or <tt>10</tt>.
</p>

<p>
Again, as per usual, <tt>listen()</tt> returns <tt>-1</tt> and sets
<tt>errno</tt> on error.
</p>

<p>
Well, as you can probably imagine, we need to call <tt>bind()</tt> before we call
<tt>listen()</tt> or the kernel will have us listening on a random port.
Bleah!  So if you're going to be listening for incoming connections, the
sequence of system calls you'll make is:
<pre>
    socket();
    bind();
    listen();
    /* accept() goes here */
</pre>
I'll just leave that in the place of sample code, since it's fairly
self-explanatory.  (The code in the <tt>accept()</tt> section, below, is
more complete.)  The really tricky part of this whole sha-bang is the
call to <tt>accept()</tt>.
</p>

<hr>

<p>
<h2><a name="accept"><tt>accept()</tt>--"Thank you for calling port 3490."</a></h2>
Get ready--the <tt>accept()</tt> call is kinda weird!  What's going to
happen is this: someone far far away will try to <tt>connect()</tt> to
your machine on a port that you are <tt>listen()</tt>'ing on.  Their
connection will be queued up waiting to be <tt>accept()</tt>'ed.  You
call <tt>accept()</tt> and you tell it to get the pending connection.
It'll return to you a <i>brand new socket file
descriptor</i> to use for this single connection!  That's right, suddenly
you have <i>two socket file descriptors</i> for the price of one!  The
original one is still listening on your port and the newly created one
is finally ready to <tt>send()</tt> and <tt>recv()</tt>.  We're there!
</p>

<p>
The call is as follows:
<pre>
     #include &lt;sys/socket.h&gt; 

     int accept(int sockfd, void *addr, int *addrlen);
</pre>
<tt>sockfd</tt> is the <tt>listen()</tt>'ing socket descriptor.  Easy
enough.  <tt>addr</tt> will usually be a pointer to a local <tt>struct
sockaddr_in</tt>.  This is where the information about the incoming
connection will go (and you can determine which host is calling you from
which port).  <tt>addrlen</tt> is a local integer variable that should
be set to <nobr><tt>sizeof(struct sockaddr_in)</tt></nobr> before its
address is passed to <tt>accept()</tt>.  Accept will not put more than
that many bytes into <tt>addr</tt>. If it puts fewer in, it'll change
the value of <tt>addrlen</tt> to reflect that.
</p>

<p>
Guess what?  <tt>accept()</tt> returns <tt>-1</tt> and sets
<tt>errno</tt> if an error occurs.  Betcha didn't figure that.
</p>

<p>
Like before, this is a bunch to absorb in one chunk, so here's a sample code
fragment for your perusal:
<pre>
    #include &lt;string.h&gt; 
    #include &lt;sys/types.h&gt; 
    #include &lt;sys/socket.h&gt; 

    #define MYPORT 3490    /* the port users will be connecting to */

    #define BACKLOG 10     /* how many pending connections queue will hold */

    main()
    {
        int sockfd, new_fd;  /* listen on sock_fd, new connection on new_fd */
        struct sockaddr_in my_addr;    /* my address information */
        struct sockaddr_in their_addr; /* connector's address information */
        int sin_size;

        sockfd = socket(AF_INET, SOCK_STREAM, 0); /* do some error checking! */

        my_addr.sin_family = AF_INET;         /* host byte order */
        my_addr.sin_port = htons(MYPORT);     /* short, network byte order */
        my_addr.sin_addr.s_addr = INADDR_ANY; /* auto-fill with my IP */
        bzero(&(my_addr.sin_zero), 8);        /* zero the rest of the struct */

        /* don't forget your error checking for these calls: */
        bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr));

        listen(sockfd, BACKLOG);

        sin_size = sizeof(struct sockaddr_in);
        new_fd = accept(sockfd, &their_addr, &sin_size);
        .
        .
        .
</pre>
Again, note that we will use the socket descriptor <tt>new_fd</tt> for
all <tt>send()</tt> and <tt>recv()</tt> calls.  If you're only getting
one single connection ever, you can <tt>close()</tt> the original
<tt>sockfd</tt> in order to prevent more incoming
connections on the same port, if you so desire.
</p>


<hr>

<p>
<h2><a name="sendrecv"><tt>send()</tt> and <tt>recv()</tt>--Talk to me,
baby!</a></h2>
These two functions are for communicating over stream sockets or
connected datagram sockets.  If you want to use regular unconnected
datagram sockets, you'll need to see the section on <a
href="#sendtorecv"><tt>sendto()</tt> and <tt>recvfrom()</tt></a>,
below.
</p>

<p>
The <tt>send()</tt> call:
<pre>
    int send(int sockfd, const void *msg, int len, int flags);
</pre>
<tt>sockfd</tt> is the socket descriptor you want to send data to
(whether it's the one returned by <tt>socket()</tt> or the one you got
with <tt>accept()</tt>.)  <tt>msg</tt> is a pointer to the data you want
to send, and <tt>len</tt> is the length of that data in bytes.  Just set
<tt>flags</tt> to <tt>0</tt>.  (See the <a
href="man.cgi?send"><tt>send()</tt> man page</a> for more information
concerning flags.)
</p>

<p>
Some sample code might be:
<pre>
    char *msg = "Beej was here!";
    int len, bytes_sent;
    .
    .
    len = strlen(msg);
    bytes_sent = send(sockfd, msg, len, 0);
    .
    .
    .
</pre>
<tt>send()</tt> returns the number of bytes actually sent out--<b>this
might be less than the number you told it to send!</b>  See, sometimes you
tell it to send a whole gob of data and it just can't handle it.  It'll
fire off as much of the data as it can, and trust you to send the rest
later.  Remember, if the value returned by <tt>send()</tt> doesn't match
doesn't match the value in <tt>len</tt>, it's up to you to send the rest
of the string.  The good news is this: if the packet is small (less than
1K or so) it will <i>probably</i> manage to send the whole thing all in
one go.  Again, <tt>-1</tt> is returned on error, and
<tt>errno</tt> is set to the error number.
</p>

<p>
The <tt>recv()</tt> call is similar in many respects:
<pre>
    int recv(int sockfd, void *buf, int len, unsigned int flags);
</pre>
<tt>sockfd</tt> is the socket descriptor to read from, <tt>buf</tt> is
the buffer to read the information into, <tt>len</tt> is the maximum
length of the buffer, and <tt>flags</tt> can again be set to <tt>0</tt>.
(See the <a href="man.cgi?recv"><tt>recv()</tt> man page</a> for flag
information.)
</p>

<p>
<tt>recv()</tt> returns the number of bytes actually read into the
buffer, or <tt>-1</tt> on error (with <tt>errno</tt> set, accordingly.)
</p>

<p>
There, that was easy, wasn't it?  You can now pass data back and forth
on stream sockets!  Whee!  You're a Unix Network Programmer!
</p>

<hr>

<p>
<h2><a name="sendtorecv"><tt>sendto()</tt> and <tt>recvfrom()</tt>--Talk to me,
DGRAM-style</a></h2>
"This is all fine and dandy," I hear you saying, "but where does this
leave me with unconnected datagram sockets?"  No problemo, amigo.  We
have just the thing.
</p>

<p>
Since datagram sockets aren't connected to a remote host, guess which
piece of information we need to give before we send a packet?  That's
right!  The destination address!  Here's the scoop:
<pre>
    int sendto(int sockfd, const void *msg, int len, unsigned int flags,
               const struct sockaddr *to, int tolen);
</pre>
As you can see, this call is basically the same as the call to
<tt>send()</tt> with the addition of two other pieces of information.
<tt>to</tt> is a pointer to a <nobr><tt>struct sockaddr</tt></nobr>
(which you'll probably have as a <nobr><tt>struct
sockaddr_in</tt></nobr> and cast it at the last minute) which contains
the destination IP address and port.  <tt>tolen</tt> can simply be set
to <nobr><tt>sizeof(struct sockaddr)</tt></nobr>.
</p>

<p>
Just like with <tt>send()</tt>, <tt>sendto()</tt> returns the number of
bytes actually sent (which, again, might be less than the number of bytes you
told it to send!), or <tt>-1</tt> on error.
</p>

<p>
Equally similar are <tt>recv()</tt> and <tt>recvfrom()</tt>.  The
synopsis of <tt>recvfrom()</tt> is:
<pre>
    int recvfrom(int sockfd, void *buf, int len, unsigned int flags
                 struct sockaddr *from, int *fromlen);
</pre>
Again, this is just like <tt>recv()</tt> with the addition of a couple
fields.  <tt>from</tt> is a pointer to a local <nobr><tt>struct
sockaddr</tt></nobr> that will be filled with the IP address and port of
the originating machine.  <tt>fromlen</tt> is a pointer to a local
<tt>int</tt> that should be initialized to <nobr><tt>sizeof(struct
sockaddr)</tt></nobr>.  When the function returns, <tt>fromlen</tt> will
contain the length of the address actually stored in <tt>from</tt>.
</p>

<p>
<tt>recvfrom()</tt> returns the number of bytes received, or
<tt>-1</tt> on error (with <tt>errno</tt> set accordingly.)
</p>

<p>
Remember, if you <tt>connect()</tt> a datagram socket, you can then
simply use <tt>send()</tt> and <tt>recv()</tt> for all your
transactions.  The socket itself is still a datagram socket and the
packets still use UDP, but the socket interface will automatically add
the destination and source information for you.
</p>

<hr>

<p>
<h2><a name="closedown"><tt>close()</tt> and <tt>shutdown()</tt>--Get outta my face!</a></h2>
Whew!  You've been <tt>send()</tt>'ing and <tt>recv()</tt>'ing data all
day long, and you've had it.  You're ready to close the connection on
your socket descriptor.  This is easy.  You can just use the regular
Unix file descriptor <tt>close()</tt> function:
<pre>
    close(sockfd);
</pre>
This will prevent any more reads and writes to the socket.  Anyone
attempting to read or write the socket on the remote end will receive an
error.
</p>

<p>
Just in case you want a little more control over how the socket closes,
you can use the <tt>shutdown()</tt> function.  It allows you to cut off
communication in a certain direction, or both ways (just like
<tt>close()</tt> does.)  Synopsis:
<pre>
    int shutdown(int sockfd, int how);
</pre>
<tt>sockfd</tt> is the socket file descriptor you want to shutdown, and
<tt>how</tt> is one of the following:
<ul>
<li><tt>0</tt> - Further receives are disallowed</li>
<li><tt>1</tt> - Further sends are disallowed</li>
<li><tt>2</tt> - Further sends and receives are disallowed (like
<tt>close()</tt>)</li>
</ul>
</p>

<p>
<tt>shutdown()</tt> returns <tt>0</tt> on success, and <tt>-1</tt> on error (with
<tt>errno</tt> set accordingly.)
</p>

<p>
If you deign to use <tt>shutdown()</tt> on unconnected datagram sockets,
it will simply make the socket unavailable for further <tt>send()</tt>
and <tt>recv()</tt> calls (remember that you can use these if you
<tt>connect()</tt> your datagram socket.)
</p>

<p>
Nothing to it.
</p>

<hr>

<p>
<h2><a name="getpeername"><tt>getpeername()</tt>--Who are you?</a></h2>
This function is so easy.
</p>

<p>
It's so easy, I almost didn't give it it's own section.  But here it is
anyway.
</p>

<p>
The function <tt>getpeername()</tt> will tell you who is at the other end
of a connected stream socket.  The synopsis:
<pre>
    #include &lt;sys/socket.h&gt; 

    int getpeername(int sockfd, struct sockaddr *addr, int *addrlen);
</pre>
<tt>sockfd</tt> is the descriptor of the connected stream socket,
<tt>addr</tt> is a pointer to a <nobr><tt>struct sockaddr</tt></nobr>
(or a <nobr><tt>struct sockaddr_in</tt></nobr>) that will hold the
information about the other side of the connection, and <tt>addrlen</tt>
is a pointer to an <tt>int</tt>, that should be initialized to
<nobr><tt>sizeof(struct sockaddr)</tt></nobr>.
</p>

<p>
The function returns <tt>-1</tt> on error and sets <tt>errno</tt>
accordingly.
</p>

<p>
Once you have their address, you can use <tt>inet_ntoa()</tt> or
<tt>gethostbyaddr()</tt> to print or get more information.  No, you
can't get their login name.  (Ok, ok.  If the other computer is running
an ident daemon, this is possible.  This, however, is beyond the scope
of this document.  Check out
<a href=ftp://nic.ddn.mil/rfc/rfc1413.txt>RFC-1413</a> for more info.)
</p>

<hr>

<p>
<h2><a name="gethostname"><tt>gethostname()</tt>--Who am I?</a></h2>

Even easier than <tt>getpeername()</tt> is the function
<tt>gethostname()</tt>.  It returns the name of the computer that your
program is running on.  The name can then be used by
<tt>gethostbyname()</tt>, below, to determine the IP address of your
local machine.

<p>
What could be more fun?  I could think of a few things, but they don't
pertain to socket programming.  Anyway, here's the breakdown:

<p>
<pre>
    #include &lt;unistd.h&gt;

    int gethostname(char *hostname, size_t size);
</pre>

<p>
The arguments are simple: <tt>hostname</tt> is a pointer to an array of
chars that will contain the hostname upon the function's return, and
<tt>size</tt> is the length in bytes of the <tt>hostname</tt> array.

<p>
The function returns <tt>0</tt> on successful completion, and
<tt>-1</tt> on error, setting <tt>errno</tt> as usual.

<hr>

<p>
<h2><a name="dns">DNS--You say "whitehouse.gov", I say "198.137.240.100"</a></h2>
In case you don't know what DNS is, it stands for "Domain Name Service".
In a nutshell, you tell it what the human-readable address is for a
site, and it'll give you the IP address (so you can use it with
<tt>bind()</tt>, <tt>connect()</tt>, <tt>sendto()</tt>, or whatever
you need it for.)  This way, when someone enters:
<pre>
    $ telnet whitehouse.gov
</pre>
<tt>telnet</tt> can find out that it needs to <tt>connect()</tt> to
"198.137.240.100".
</p>

<p>
But how does it work?  You'll be using the function
<tt>gethostbyname()</tt>:
<pre>
    #include &lt;netdb.h&gt; 
    
    struct hostent *gethostbyname(const char *name);
</pre>
As you see, it returns a pointer to a <nobr><tt>struct
hostent</tt></nobr>, the layout of which is as follows:
<pre>
    struct hostent {
        char    *h_name;
        char    **h_aliases;
        int     h_addrtype;
        int     h_length;
        char    **h_addr_list;
    };
    #define h_addr h_addr_list[0]
</pre>
And here are the descriptions of the fields in the <nobr><tt>struct
hostent</tt></nobr>:
<ul>
<li><tt>h_name      - </tt>Official name of the host.</li>
<li><tt>h_aliases   - </tt>A NULL-terminated array of alternate names for
the host.</li>
<li><tt>h_addrtype  - </tt>The type of address being returned; usually
<tt>AF_INET</tt>.</li>
<li><tt>h_length    - </tt>The length of the address in bytes.</li>
<li><tt>h_addr_list - </tt>A zero-terminated array of network addresses
for the host.  Host addresses are in Network Byte Order.</li>
<li><tt>h_addr      - </tt>The first address in
<tt>h_addr_list</tt>.</li>
</ul>
</p>

<p><tt>gethostbyname()</tt> returns a pointer to the filled
<nobr><tt>struct hostent</tt></nobr>, or NULL on error.  (But
<tt>errno</tt> is <b>not</b> set--<b><tt>h_errno</tt></b> is set
instead.  See <tt>herror()</tt>, below.)
</p>

<p>
But how is it used?  Sometimes (as we find from reading computer
manuals), just spewing the information at the reader is not enough.
This function is certainly easier to use than it looks.
</p>

<p>
<a href="getip.c">Here's an example program</a>:
<pre>
    #include &lt;stdio.h&gt; 
    #include &lt;stdlib.h&gt; 
    #include &lt;errno.h&gt; 
    #include &lt;netdb.h&gt; 
    #include &lt;sys/types.h&gt
    #include &lt;netinet/in.h&gt; 

    int main(int argc, char *argv[])
    {
        struct hostent *h;

        if (argc != 2) {  /* error check the command line */
            fprintf(stderr,"usage: getip address\n");
            exit(1);
        }

        if ((h=gethostbyname(argv[1])) == NULL) {  /* get the host info */
            herror("gethostbyname");
            exit(1);
        }

        printf("Host name  : %s\n", h->h_name);
        printf("IP Address : %s\n",inet_ntoa(*((struct in_addr *)h->h_addr)));

        return 0;
    }
</pre>
With <tt>gethostbyname()</tt>, you can't use <tt>perror()</tt> to print
error message (since <tt>errno</tt> is not used).  Instead, call
<tt>herror()</tt>.
</p>

<p>
It's pretty straightforward.  You simply pass the string that contains
the machine name ("whitehouse.gov") to <tt>gethostbyname()</tt>, and
then grab the information out of the returned <nobr><tt>struct
hostent</tt></nobr>.
</p>

<p>
The only possible weirdness might be in the printing of the IP address,
above.  <tt>h->h_addr</tt> is a <nobr><tt>char *</tt></nobr>, but
<tt>inet_ntoa()</tt> wants a <nobr><tt>struct in_addr</tt></nobr> passed
to it.  So I cast <tt>h->h_addr</tt> to a <nobr><tt>struct in_addr
*</tt></nobr>, then dereference it to get at the data.  
</p>

<hr>

<p>
<h2><a name="clientserver">Client-Server Background</a></h2>
It's a client-server world, baby.  Just about everything on the network
deals with client processes talking to server processes and vice-versa.
Take <tt>telnet</tt>, for instance.  When you connect to a remote host
on port 23 with telnet (the client), a program on that host (called
<tt>telnetd</tt>, the server) springs to life.  It handles the incoming
telnet connection, sets you up with a login prompt, etc.
</p>

<p>
<center>
<a href="cli-serv.gif">
<img src="cli-serv.gif" border=0 alt="[Client-Server Relationship]">
</a>
<br>
<b>Figure 2.  The Client-Server Relationship.</b>
</center>
</p>

<p>
The exchange of information between client and server is summarized in
Figure 2.
</p>

<p>
Note that the client-server pair can speak <tt>SOCK_STREAM</tt>,
<tt>SOCK_DGRAM</tt>, or anything else (as long as they're speaking the
same thing.)  Some good examples of client-server pairs are
<tt>telnet</tt>/<tt>telnetd</tt>, <tt>ftp</tt>/<tt>ftpd</tt>, or
<tt>bootp</tt>/<tt>bootpd</tt>.  Every time you use <tt>ftp</tt>,
there's a remote program, <tt>ftpd</tt>, that serves you.
</p>

<p>
Often, there will only be one server on a machine, and that server will
handle multiple clients using <tt>fork()</tt>.  The basic routine is:
server will wait for a connection, <tt>accept()</tt> it, and
<tt>fork()</tt> a child process to handle it.  This is what our sample
server does in the next section.
</p>

<hr>

<p>
<h2><a name="simpleserver">A Simple Stream Server</a></h2>
All this server does is send the string "<tt>Hello, World!\n</tt>" out
over a stream connection.  All you need to do to test this server is run
it in one window, and telnet to it from another with:
<pre>
    $ telnet remotehostname 3490
</pre>
where <tt>remotehostname</tt> is the name of the machine you're running
it on.
</p>

<p>
<a href="server.c">The server code</a>: (Note: a trailing backslash on a
line means that the line is continued on the next.)
<pre>
    #include &lt;stdio.h&gt; 
    #include &lt;stdlib.h&gt; 
    #include &lt;errno.h&gt; 
    #include &lt;string.h&gt; 
    #include &lt;sys/types.h&gt; 
    #include &lt;netinet/in.h&gt; 
    #include &lt;sys/socket.h&gt; 
    #include &lt;sys/wait.h&gt; 

    #define MYPORT 3490    /* the port users will be connecting to */

    #define BACKLOG 10     /* how many pending connections queue will hold */

    main()
    {
        int sockfd, new_fd;  /* listen on sock_fd, new connection on new_fd */
        struct sockaddr_in my_addr;    /* my address information */
        struct sockaddr_in their_addr; /* connector's address information */
        int sin_size;

        if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
            perror("socket");
            exit(1);
        }

        my_addr.sin_family = AF_INET;         /* host byte order */
        my_addr.sin_port = htons(MYPORT);     /* short, network byte order */
        my_addr.sin_addr.s_addr = INADDR_ANY; /* auto-fill with my IP */
        bzero(&(my_addr.sin_zero), 8);        /* zero the rest of the struct */

        if (bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) \
                                                                      == -1) {
            perror("bind");
            exit(1);
        }

        if (listen(sockfd, BACKLOG) == -1) {
            perror("listen");
            exit(1);
        }

        while(1) {  /* main accept() loop */
            sin_size = sizeof(struct sockaddr_in);
            if ((new_fd = accept(sockfd, (struct sockaddr *)&their_addr, \
                                                          &sin_size)) == -1) {
                perror("accept");
                continue;
            }
            printf("server: got connection from %s\n", \
                                               inet_ntoa(their_addr.sin_addr));
            if (!fork()) { /* this is the child process */
                if (send(new_fd, "Hello, world!\n", 14, 0) == -1)
                    perror("send");
                close(new_fd);
                exit(0);
            }
            close(new_fd);  /* parent doesn't need this */

            while(waitpid(-1,NULL,WNOHANG) > 0); /* clean up child processes */
        }
    }
</pre>
In case you're curious, I have the code in one big
<tt>main()</tt> function for (I feel) syntactic clarity.  Feel free to
split it into smaller functions if it makes you feel better.
</p>

<p>
You can also get the string from this server by using the client listed
in the next section.
</p>

<hr>

<p>
<h2><a name="simpleclient">A Simple Stream Client</a></h2>
This guy's even easier than the server.  All this client does is connect
to the host you specify on the command line, port 3490.  It gets the
string that the server sends.
</p>

<p>
<a href="client.c">The client source</a>:
<pre>
    #include &lt;stdio.h&gt; 
    #include &lt;stdlib.h&gt; 
    #include &lt;errno.h&gt; 
    #include &lt;string.h&gt; 
    #include &lt;netdb.h&gt; 
    #include &lt;sys/types.h&gt; 
    #include &lt;netinet/in.h&gt; 
    #include &lt;sys/socket.h&gt; 

    #define PORT 3490    /* the port client will be connecting to */

    #define MAXDATASIZE 100 /* max number of bytes we can get at once */

    int main(int argc, char *argv[])
    {
        int sockfd, numbytes;  
        char buf[MAXDATASIZE];
        struct hostent *he;
        struct sockaddr_in their_addr; /* connector's address information */

        if (argc != 2) {
            fprintf(stderr,"usage: client hostname\n");
            exit(1);
        }

        if ((he=gethostbyname(argv[1])) == NULL) {  /* get the host info */
            herror("gethostbyname");
            exit(1);
        }

        if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
            perror("socket");
            exit(1);
        }

        their_addr.sin_family = AF_INET;      /* host byte order */
        their_addr.sin_port = htons(PORT);    /* short, network byte order */
        their_addr.sin_addr = *((struct in_addr *)he->h_addr);
        bzero(&(their_addr.sin_zero), 8);     /* zero the rest of the struct */

        if (connect(sockfd, (struct sockaddr *)&their_addr, \
                                              sizeof(struct sockaddr)) == -1) {
            perror("connect");
            exit(1);
        }

        if ((numbytes=recv(sockfd, buf, MAXDATASIZE, 0)) == -1) {
            perror("recv");
            exit(1);
        }

        buf[numbytes] = '\0';

        printf("Received: %s",buf);

        close(sockfd);

        return 0;
    }
</pre>
</p>

<p>
Notice that if you don't run the server before you run the client,
<tt>connect()</tt> returns "Connection refused".  Very useful.
</p>

<hr>

<p>
<h2><a name="datagram">Datagram Sockets</a></h2>
I really don't have that much to talk about here, so I'll just present a
couple of sample programs: <tt>talker.c</tt> and <tt>listener.c</tt>.
</p>

<p>
<tt>listener</tt> sits on a machine waiting for an incoming packet on
port 4950.  <tt>talker</tt> sends a packet to that port, on the
specified machine, that contains whatever the user enters on the command
line.
</p>

<p>
Here is the <a href="listener.c">source for <tt>listener.c</tt></a>:
<pre>
    #include &lt;stdio.h&gt; 
    #include &lt;stdlib.h&gt; 
    #include &lt;errno.h&gt; 
    #include &lt;string.h&gt; 
    #include &lt;sys/types.h&gt; 
    #include &lt;netinet/in.h&gt; 
    #include &lt;sys/socket.h&gt; 
    #include &lt;sys/wait.h&gt; 

    #define MYPORT 4950    /* the port users will be sending to */

    #define MAXBUFLEN 100

    main()
    {
        int sockfd;
        struct sockaddr_in my_addr;    /* my address information */
        struct sockaddr_in their_addr; /* connector's address information */
        int addr_len, numbytes;
        char buf[MAXBUFLEN];

        if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
            perror("socket");
            exit(1);
        }

        my_addr.sin_family = AF_INET;         /* host byte order */
        my_addr.sin_port = htons(MYPORT);     /* short, network byte order */
        my_addr.sin_addr.s_addr = INADDR_ANY; /* auto-fill with my IP */
        bzero(&(my_addr.sin_zero), 8);        /* zero the rest of the struct */

        if (bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) \
                                                                       == -1) {
            perror("bind");
            exit(1);
        }

        addr_len = sizeof(struct sockaddr);
        if ((numbytes=recvfrom(sockfd, buf, MAXBUFLEN, 0, \
                           (struct sockaddr *)&their_addr, &addr_len)) == -1) {
            perror("recvfrom");
            exit(1);
        }

        printf("got packet from %s\n",inet_ntoa(their_addr.sin_addr));
        printf("packet is %d bytes long\n",numbytes);
        buf[numbytes] = '\0';
        printf("packet contains \"%s\"\n",buf);

        close(sockfd);
    }
</pre>
Notice that in our call to <tt>socket()</tt> we're finally using
<tt>SOCK_DGRAM</tt>.  Also, note that there's no need to
<tt>listen()</tt> or <tt>accept()</tt>.  This is one
of the perks of using unconnected datagram sockets!
</p>

<p>
Next comes the <a href="talker.c">source for <tt>talker.c</tt></a>:
<pre>
    #include &lt;stdio.h&gt; 
    #include &lt;stdlib.h&gt; 
    #include &lt;errno.h&gt; 
    #include &lt;string.h&gt; 
    #include &lt;sys/types.h&gt; 
    #include &lt;netinet/in.h&gt; 
    #include &lt;netdb.h&gt; 
    #include &lt;sys/socket.h&gt; 
    #include &lt;sys/wait.h&gt; 

    #define MYPORT 4950    /* the port users will be sending to */

    int main(int argc, char *argv[])
    {
        int sockfd;
        struct sockaddr_in their_addr; /* connector's address information */
        struct hostent *he;
        int numbytes;

        if (argc != 3) {
            fprintf(stderr,"usage: talker hostname message\n");
            exit(1);
        }

        if ((he=gethostbyname(argv[1])) == NULL) {  /* get the host info */
            herror("gethostbyname");
            exit(1);
        }

        if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
            perror("socket");
            exit(1);
        }

        their_addr.sin_family = AF_INET;      /* host byte order */
        their_addr.sin_port = htons(MYPORT);  /* short, network byte order */
        their_addr.sin_addr = *((struct in_addr *)he->h_addr);
        bzero(&(their_addr.sin_zero), 8);     /* zero the rest of the struct */

        if ((numbytes=sendto(sockfd, argv[2], strlen(argv[2]), 0, \
             (struct sockaddr *)&their_addr, sizeof(struct sockaddr))) == -1) {
            perror("sendto");
            exit(1);
        }

        printf("sent %d bytes to %s\n",numbytes,inet_ntoa(their_addr.sin_addr));

        close(sockfd);

        return 0;
    }
</pre>
And that's all there is to it!  Run <tt>listener</tt> on some machine,
then
run <tt>talker</tt> on another.  Watch them communicate!  Fun
G-rated excitement for the entire nuclear family!
</p>

<p>
Except for one more tiny detail that I've mentioned many times in the
past: connected datagram sockets.  I need to talk about this here, since
we're in the datagram section of the document.  Let's say that
<tt>talker</tt> calls <tt>connect()</tt> and specifies the
<tt>listener</tt>'s address.  From that point on, <tt>talker</tt> may
only sent to and receive from the address specified by
<tt>connect()</tt>.  For this reason, you don't have to use
<tt>sendto()</tt> and <tt>recvfrom()</tt>; you can simply use
<tt>send()</tt> and <tt>recv()</tt>.
</p>

<hr>

<p>
<h2><a name="blocking">Blocking</a></h2>
Blocking.  You've heard about it--now what the hell is it?  In a
nutshell, "block" is techie jargon for "sleep".  You probably noticed
that when you run <tt>listener</tt>, above, it just sits there until a
packet arrives.  What happened is that it called <tt>recvfrom()</tt>,
there was no data, and so <tt>recvfrom()</tt> is said to "block" (that
is, sleep there) until some data arrives.
</p>

<p>
Lots of functions block.  <tt>accept()</tt> blocks.  All the
<tt>recv*()</tt> functions block.  The reason they can do this is
because they're allowed to.  When you first create the socket descriptor
with <tt>socket()</tt>, the kernel sets it to blocking.  If you don't
want a socket to be blocking, you have to make a call to
<tt>fcntl()</tt>:
<pre>
    #include &lt;unistd.h&gt; 
    #include &lt;fcntl.h&gt; 
    .
    .
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    fcntl(sockfd, F_SETFL, O_NONBLOCK);
    .
    .
</pre>
</p>

<p>
By setting a socket to non-blocking, you can effectively "poll" the
socket for information.  If you try to read from a non-blocking socket
and there's no data there, it's not allowed to block--it will return
<tt>-1</tt> and <tt>errno</tt> will be set to <tt>EWOULDBLOCK</tt>.
</p>

<p>
Generally speaking, however, this type of polling is a bad idea.  If you
put your program in a busy-wait looking for data on the socket, you'll
suck up CPU time like it was going out of style.  A more elegant
solution for checking to see if there's data waiting to be read comes in
the following section on <tt>select()</tt>.

<hr>

<p>
<h2><a name="select"><tt>select()</tt>--Synchronous I/O Multiplexing</a></h2>
This function is somewhat strange, but it's very useful.  Take the
following situation: you are a server and you want to listen for
incoming connections as well as keep reading from the connections you
already have.
</p>

<p>
No problem, you say, just an <tt>accept()</tt> and a couple of
<tt>recv()</tt>s.  Not so fast, buster!  What if you're blocking on an
<tt>accept()</tt> call?  How are you going to <tt>recv()</tt> data at
the same time?  "Use non-blocking sockets!"  No way!  You don't want to
be a CPU hog.  What, then?
</p>

<p>
<tt>select()</tt> gives you the power to monitor several sockets at the
same time.  It'll tell you which ones are ready for reading, which are
ready for writing, and which sockets have raised exceptions, if you
really want to know that.
</p>

<p>
Without any further ado, I'll offer the synopsis of <tt>select()</tt>:
<pre>
       #include &lt;sys/time.h&gt; 
       #include &lt;sys/types.h&gt; 
       #include &lt;unistd.h&gt; 

       int select(int numfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);
</pre>

<p>
The function monitors "sets" of file descriptors; in particular
<tt>readfds</tt>, <tt>writefds</tt>, and <tt>exceptfds</tt>.  If you
want to see if you can read from standard input and some socket
descriptor, <tt>sockfd</tt>, just add the file descriptors <tt>0</tt> and
<tt>sockfd</tt> to the set <tt>readfds</tt>.  The parameter
<tt>numfds</tt> should be set to the values of the highest file
descriptor plus one.  In this example, it should be set to
<tt>sockfd+1</tt>, since it is assuredly higher than standard input
(<tt>0</tt>).
</p>

<p>
When <tt>select()</tt> returns, <tt>readfds</tt> will be modified to
reflect which of the file descriptors you selected is ready for reading.
You can test them with the macro <tt>FD_ISSET()</tt>, below.
</p>

<p>
Before progressing much further, I'll talk about how to manipulate these
sets.  Each set is of the type <tt>fd_set</tt>.  The following macros
operate on this type:
<ul>
<li><tt>FD_ZERO(fd_set *set)</tt> - clears a file descriptor set</li>
<li><tt>FD_SET(int fd, fd_set *set)</tt> - adds <tt>fd</tt> to the set</li>
<li><tt>FD_CLR(int fd, fd_set *set)</tt> - removes <tt>fd</tt> from the set</li>
<LI><tt>FD_ISSET(int fd, fd_set *set)</tt> - tests to see if <tt>fd</tt> is in the set</li>
</ul>
</p>

<p>
Finally, what is this weirded out <nobr><tt>struct timeval</tt></nobr>?  Well,
sometimes you don't want to wait forever for someone to send you some
data.  Maybe every 96 seconds you want to print "Still Going..." to the
terminal even though nothing has happened.  This time structure allows
you to specify a timeout period.  If the time is exceeded and
<tt>select()</tt> still hasn't found any ready file descriptors, it'll
return so you can continue processing.
</p>

<p>
The <tt>struct timeval</tt> has the follow fields:
<pre>
    struct timeval {
        int tv_sec;     /* seconds */
        int tv_usec;    /* microseconds */
    };
</pre>
Just set <tt>tv_sec</tt> to the number of seconds to wait, and set
<tt>tv_usec</tt> to the number of microseconds to wait.  Yes, that's
<i>micro</i>seconds, not milliseconds.  There are 1,000 microseconds in a
millisecond, and 1,000 milliseconds in a second.  Thus, there are
1,000,000 microseconds in a second.  Why is it "usec"?  The "u"
is supposed to look like the Greek letter Mu that we use for "micro".
Also, when the function returns, <tt>timeout</tt> <i>might</i> be
updated to show the time still remaining.  This depends on what flavor
of Unix you're running.
</p>

<p>
Yay!  We have a microsecond resolution timer!  Well, don't count on
it.  Standard Unix timeslice is 100 milliseconds, so you'll probably
have to wait at least that long, no matter how small you set your
<nobr><tt>struct timeval</tt></nobr>.
</p>

<p>
Other things of interest:  If you set the fields in your
<nobr><tt>struct timeval</tt></nobr> to <tt>0</tt>, <tt>select()</tt>
will timeout immediately, effectively polling all the file descriptors
in your sets.  If you set the  parameter <tt>timeout</tt> to NULL, it
will never timeout, and will wait until the first file descriptor is
ready.  Finally, if you don't care about waiting for a certain set, you
can just set it to NULL in the call to <tt>select()</tt>.
</p>

<p>
<a href="select.c">The following code snippet</a> waits 2.5 seconds for
something to appear on standard input:
<pre>
       #include &lt;sys/time.h&gt; 
       #include &lt;sys/types.h&gt; 
       #include &lt;unistd.h&gt; 

       #define STDIN 0  /* file descriptor for standard input */

       main()
       {
           struct timeval tv;
           fd_set readfds;

           tv.tv_sec = 2;
           tv.tv_usec = 500000;

           FD_ZERO(&readfds);
           FD_SET(STDIN, &readfds);

           /* don't care about writefds and exceptfds: */
           select(STDIN+1, &readfds, NULL, NULL, &tv);

           if (FD_ISSET(STDIN, &readfds))
               printf("A key was pressed!\n");
           else
               printf("Timed out.\n");
       }
</pre>
If you're on a line buffered terminal, the key you hit should be RETURN
or it will time out anyway.
</p>

<p>
Now, some of you might think this is a great way to wait for data on a
datagram socket--and you are right: it <i>might</i> be.  Some Unices
can use select in this manner, and some can't.  You should see what your
local man page says on the matter if you want to attempt it.

<p>
One final note of interest about <tt>select()</tt>: if you have a socket
that is <tt>listen()</tt>'ing, you can check to see if there is a new
connection by putting that socket's file descriptor in the
<tt>readfds</tt> set.
</p>

<p>
And that, my friends, is a quick overview of the almighty
<tt>select()</tt> function.
</p>

<hr>

<p>
<h2><a name="reference">More References</a></h2>
You've come this far, and now you're screaming for more!  Where else can
you go to learn more about all this stuff?
</p>

<p>
Try the following man pages, for starters:
<ul>
<li><a href="man.cgi?socket"><tt>socket()</tt></a></li>
<li><a href="man.cgi?bind"><tt>bind()</tt></a></li>
<li><a href="man.cgi?connect"><tt>connect()</tt></a></li>
<li><a href="man.cgi?listen"><tt>listen()</tt></a></li>
<li><a href="man.cgi?accept"><tt>accept()</tt></a></li>
<li><a href="man.cgi?send"><tt>send()</tt></a></li>
<li><a href="man.cgi?recv"><tt>recv()</tt></a></li>
<li><a href="man.cgi?sendto"><tt>sendto()</tt></a></li>
<li><a href="man.cgi?recvfrom"><tt>recvfrom()</tt></a></li>
<li><a href="man.cgi?close"><tt>close()</tt></a></li>
<li><a href="man.cgi?shutdown"><tt>shutdown()</tt></a></li>
<li><a href="man.cgi?getpeername"><tt>getpeername()</tt></a></li>
<li><a href="man.cgi?getsockname"><tt>getsockname()</tt></a></li>
<li><a href="man.cgi?gethostbyname"><tt>gethostbyname()</tt></a></li>
<li><a href="man.cgi?gethostbyaddr"><tt>gethostbyaddr()</tt></a></li>
<li><a href="man.cgi?getprotobyname"><tt>getprotobyname()</tt></a></li>
<li><a href="man.cgi?fcntl"><tt>fcntl()</tt></a></li>
<li><a href="man.cgi?select"><tt>select()</tt></a></li>
<li><a href="man.cgi?perror"><tt>perror()</tt></a></li>
</ul>
</p>

<p>
<dl>
<dt>Also, look up the following <a
href="http://www.clbooks.com/">books</a>:</dt><br><br>
<dd><b>Internetworking with TCP/IP, volumes I-III</b> by Douglas E. Comer
and David L. Stevens.  Published by Prentice Hall.  Second
edition ISBNs: 0-13-468505-9, 0-13-472242-6, 0-13-474222-2.  There is a
third edition of this set which covers IPv6 and IP over ATM.
<br><br>
<dd><b>Using C on the UNIX System</b> by David A. Curry.  Published by
O'Reilly & Associates, Inc.  ISBN 0-937175-23-4.
<br><br>
<dd><b>TCP/IP Network Administration</b> by Craig Hunt.  Published by
O'Reilly & Associates, Inc.  ISBN 0-937175-82-X.
<br><br>
<dd><b>TCP/IP Illustrated, volumes 1-3</b> by W. Richard Stevens and
Gary R. Wright.  Published by Addison Wesley.  ISBNs: 0-201-63346-9,
0-201-63354-X, 0-201-63495-3.
<br><br>
<b>Unix Network Programming</b> by W. Richard Stevens.  Published by
Prentice Hall.  ISBN 0-13-949876-1.</dd>
</dl>
</p>

<p>
<dl>
<dt>On the web:</dt><br><br>

<dd><a href=http://www.cs.umn.edu/~bentlema/unix/>
<b>BSD Sockets: A Quick And Dirty Primer</b></a><br>
(http://www.cs.umn.edu/~bentlema/unix/--has other great Unix system
programming info, too!)<br><br>

<b><a href="http://pandonia.canberra.edu.au/ClientServer/socket.html">Client-Server
Computing</a></b><br>
(http://pandonia.canberra.edu.au/ClientServer/socket.html)<br><br>

<b><a href="gopher://gopher-chem.ucdavis.edu/11/Index/Internet_aw/Intro_the_Internet/intro.to.ip/">
Intro to TCP/IP</a></b> (gopher)<br>
(gopher://gopher-chem.ucdavis.edu/11/Index/Internet_aw/Intro_the_Internet/intro.to.ip/)<br><br>

<b><a href="http://web.cnam.fr/Network/TCP-IP/"><b>Internet Protocol Frequently
Asked Questions</b></a> (France)<br>
(http://web.cnam.fr/Network/TCP-IP/)<br><br>

<b><a href=http://www.ibrado.com/sock-faq/>The Unix Socket
FAQ</a></b><br>
(http://www.ibrado.com/sock-faq/)<br>

</dd>
</dl>
</p>

<p>
<dl>
<dt>RFCs--the real dirt:</dt><br><br>
<dd>
<a href="ftp://nic.ddn.mil/rfc/rfc768.txt"><b>RFC-768</b></a> -- The
User Datagram Protocol (UDP)<br>
(ftp://nic.ddn.mil/rfc/rfc768.txt)<br><br>

<a href="ftp://nic.ddn.mil/rfc/rfc791.txt"><b>RFC-791</b></a> -- The
Internet Protocol (IP)<br>
(ftp://nic.ddn.mil/rfc/rfc791.txt)<br><br>

<a href="ftp://nic.ddn.mil/rfc/rfc793.txt"><b>RFC-793</b></a> -- The
Transmission Control Protocol (TCP)<br>
(ftp://nic.ddn.mil/rfc/rfc793.txt)<br><br>

<a href="ftp://nic.ddn.mil/rfc/rfc854.txt"><b>RFC-854</b></a> -- The
Telnet Protocol<br>
(ftp://nic.ddn.mil/rfc/rfc854.txt)<br><br>

<a href="ftp://nic.ddn.mil/rfc/rfc951.txt"><b>RFC-951</b></a> -- The
Bootstrap Protocol (BOOTP)<br>
(ftp://nic.ddn.mil/rfc/rfc951.txt)<br><br>

<a href="ftp://nic.ddn.mil/rfc/rfc1350.txt"><b>RFC-1350</b></a> -- The
Trivial File Transfer Protocol (TFTP)<br>
(ftp://nic.ddn.mil/rfc/rfc1350.txt)<br>
</dd>
</dl>
</p>

<hr>

<p>
<h2><a name="disclaimer">Disclaimer and Call for Help</a></h2>
Well, that's the lot of it.  Hopefully at least some of the information
contained within this document has been remotely accurate and I
sincerely hope there aren't any glaring errors.  Well, sure, there
always are.
</p>

<p>
So, if there are, that's tough for you.  I'm sorry if any inaccuracies
contained herein have caused you any grief, but you just can't hold me
accountable.  See, I don't stand behind a single word of this document,
legally speaking.  This is my warning to you: the whole thing could be a
load of crap.
</p>

<p>
But it's probably not.  After all, I've spent many many hours messing
with this stuff, and implemented several TCP/IP network utilities for
Windows (including Telnet) as summer work.  I'm not the sockets god; I'm
just some guy.
</p>

<p>
By the way, if anyone has any constructive (or destructive) criticism
about this document, please send mail to <a
href="mailto:beej@ecst.csuchico.edu">beej@ecst.csuchico.edu</a> and I'll
try to make an effort to set the record straight.
</p>

<p>
In case you're wondering why I did this, well, I did it for the money.
Hah!  No, really, I did it because a lot of people have asked me
socket-related questions and when I tell them I've been thinking about
putting together a socket page, they say, "cool!"  Besides, I feel that
all this hard-earned knowledge is going to waste if I can't share it
with others.  WWW just happens to be the perfect vehicle.  I encourage
others to provide similar information whenever possible.
</p>

<p>
Enough of this--back to coding! ;-)
</p>

<hr size=5>

<small><b>Copyright &copy 1995, 1996 by Brian "Beej" Hall.  This guide may be
reprinted in any medium provided that its content is not altered, it is
presented in its entirety, and this copyright notice remains
intact. Contact <i><a
href=mailto:beej@ecst.csuchico.edu>beej@ecst.csuchico.edu</a></i> for more
information.</b></small>

</body>
</html>
